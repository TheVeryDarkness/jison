import { JisonParser, JisonParserApi, StateType, SymbolsType, TerminalsType, ProductionsType } from '@ts-jison/parser';
/**
 * parser generated by  @ts-jison/parser-generator 0.3.0
 * @returns Parser implementing JisonParserApi and a Lexer implementing JisonLexerApi.
 */

    import {Choice, Concat, Empty, CaptureGroup, SpecialGroup, Cardinality, LookAhead, LookBehind, Wildcard, Begin, End, Literal, Assertion, Operator, Reference, CharacterClass} from './RegexpAtom';


function prepareCharacterClass (s: string) {
    s = s.replace(/\\r/g, "\r");
    s = s.replace(/\\f/g, "\f");
    s = s.replace(/\\n/g, "\n");
    s = s.replace(/\\t/g, "\t");
    s = s.replace(/\\v/g, "\v");
    return s;
}

export class LexRegexpParser extends JisonParser implements JisonParserApi {
    $?: any;
    symbols_: SymbolsType = {"error":2,"regex":3,"regex_list":4,"EOF":5,"|":6,"regex_concat":7,"regex_base":8,"(":9,")":10,"SPECIAL_GROUP":11,"+":12,"*":13,"?":14,"/":15,"/!":16,"name_expansion":17,"range_regex":18,"any_group_regex":19,".":20,"^":21,"$":22,"string":23,"escape_char":24,"NAME_BRACE":25,"ANY_GROUP_REGEX":26,"ASSERTION":27,"OPERATOR":28,"RANGE_REGEX":29,"STRING_LIT":30,"CHARACTER_LIT":31,"$accept":0,"$end":1};
    terminals_: TerminalsType = {2:"error",5:"EOF",6:"|",9:"(",10:")",11:"SPECIAL_GROUP",12:"+",13:"*",14:"?",15:"/",16:"/!",20:".",21:"^",22:"$",25:"NAME_BRACE",26:"ANY_GROUP_REGEX",27:"ASSERTION",28:"OPERATOR",29:"RANGE_REGEX",30:"STRING_LIT",31:"CHARACTER_LIT"};
    productions_: ProductionsType = [0,[3,2],[4,3],[4,2],[4,1],[4,0],[7,2],[7,1],[8,3],[8,3],[8,2],[8,2],[8,2],[8,2],[8,2],[8,1],[8,2],[8,1],[8,1],[8,1],[8,1],[8,1],[8,1],[17,1],[19,1],[24,1],[24,1],[18,1],[23,1],[23,1]];
    table: Array<StateType>;
    defaultActions: {[key:number]: any} = {22:[2,1]};

    constructor (yy = {}, lexer = new LexRegexpLexer(yy)) {
      super(yy, lexer);

      // shorten static method to just `o` for terse STATE_TABLE
      const $V0=[2,5],$V1=[1,5],$V2=[1,6],$V3=[1,7],$V4=[1,8],$V5=[1,11],$V6=[1,12],$V7=[1,13],$V8=[1,16],$V9=[1,17],$Va=[1,20],$Vb=[1,21],$Vc=[1,18],$Vd=[1,19],$Ve=[1,23],$Vf=[5,6,10],$Vg=[5,6,9,10,11,15,16,20,21,22,25,26,27,28,30,31],$Vh=[1,25],$Vi=[1,26],$Vj=[1,27],$Vk=[1,29],$Vl=[6,10],$Vm=[5,6,9,10,11,12,13,14,15,16,20,21,22,25,26,27,28,29,30,31];
      const o = JisonParser.expandParseTable;
      this.table = [o([5,6],$V0,{3:1,4:2,7:3,8:4,17:9,19:10,23:14,24:15,9:$V1,11:$V2,15:$V3,16:$V4,20:$V5,21:$V6,22:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd}),{1:[3]},{5:[1,22],6:$Ve},o($Vf,[2,4],{17:9,19:10,23:14,24:15,8:24,9:$V1,11:$V2,15:$V3,16:$V4,20:$V5,21:$V6,22:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd}),o($Vg,[2,7],{18:28,12:$Vh,13:$Vi,14:$Vj,29:$Vk}),o($Vl,$V0,{7:3,8:4,17:9,19:10,23:14,24:15,4:30,9:$V1,11:$V2,15:$V3,16:$V4,20:$V5,21:$V6,22:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd}),o($Vl,$V0,{7:3,8:4,17:9,19:10,23:14,24:15,4:31,9:$V1,11:$V2,15:$V3,16:$V4,20:$V5,21:$V6,22:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd}),{8:32,9:$V1,11:$V2,15:$V3,16:$V4,17:9,19:10,20:$V5,21:$V6,22:$V7,23:14,24:15,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd},{8:33,9:$V1,11:$V2,15:$V3,16:$V4,17:9,19:10,20:$V5,21:$V6,22:$V7,23:14,24:15,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd},o($Vm,[2,15]),o($Vm,[2,17]),o($Vm,[2,18]),o($Vm,[2,19]),o($Vm,[2,20]),o($Vm,[2,21]),o($Vm,[2,22]),o($Vm,[2,23]),o($Vm,[2,24]),o($Vm,[2,28]),o($Vm,[2,29]),o($Vm,[2,25]),o($Vm,[2,26]),{1:[2,1]},o($Vf,[2,3],{8:4,17:9,19:10,23:14,24:15,7:34,9:$V1,11:$V2,15:$V3,16:$V4,20:$V5,21:$V6,22:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd}),o($Vg,[2,6],{18:28,12:$Vh,13:$Vi,14:$Vj,29:$Vk}),o($Vm,[2,10]),o($Vm,[2,11]),o($Vm,[2,12]),o($Vm,[2,16]),o($Vm,[2,27]),{6:$Ve,10:[1,35]},{6:$Ve,10:[1,36]},o($Vg,[2,13],{18:28,12:$Vh,13:$Vi,14:$Vj,29:$Vk}),o($Vg,[2,14],{18:28,12:$Vh,13:$Vi,14:$Vj,29:$Vk}),o($Vf,[2,2],{17:9,19:10,23:14,24:15,8:24,9:$V1,11:$V2,15:$V3,16:$V4,20:$V5,21:$V6,22:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd}),o($Vm,[2,8]),o($Vm,[2,9])];
    }

    performAction (yytext:string, yyleng:number, yylineno:number, yy:any, yystate:number /* action[1] */, $$:any /* vstack */, _$:any /* lstack */): any {
/* this == yyval */
          var $0 = $$.length - 1;
        switch (yystate) {
case 1:
 return $$[$0-1]; 
break;
case 2:
 this.$ = new Choice($$[$0-2], $$[$0]); 
break;
case 3:
 this.$ = new Choice($$[$0-1], new Empty()); 
break;
case 5:
 this.$ = new Empty(); 
break;
case 6:
 this.$ = new Concat($$[$0-1], $$[$0]); 
break;
case 8:
 this.$ = new CaptureGroup($$[$0-1]); 
break;
case 9:
 this.$ = new SpecialGroup($$[$0-2].substring(1), $$[$0-1]); 
break;
case 10:
 this.$ = new Cardinality($$[$0-1], '+'); 
break;
case 11:
 this.$ = new Cardinality($$[$0-1], '*'); 
break;
case 12:
 this.$ = new Cardinality($$[$0-1], '?'); 
break;
case 13:
 this.$ = new LookAhead($$[$0]); 
break;
case 14:
 this.$ = new LookBehind($$[$0]); 
break;
case 16:
 this.$ = new Cardinality($$[$0-1], $$[$0]); 
break;
case 18:
 this.$ = new Wildcard(); 
break;
case 19:
 this.$ = new Begin(); 
break;
case 20:
 this.$ = new End(); 
break;
case 23:
 this.$ = new Reference(yytext.substring(1, yytext.length - 1)); 
break;
case 24:
 this.$ = new CharacterClass(prepareCharacterClass(yytext.substring(1, yytext.length - 1))); 
break;
case 25:
 this.$ = new Assertion(yytext.substring(1)); 
break;
case 26:
 this.$ = new Operator(yytext.substring(1)); 
break;
case 27:
 this.$ = yytext; 
break;
case 28: case 29:
 this.$ = new Literal(yytext); 
break;
        }
    }
}


/* generated by @ts-jison/lexer-generator 0.3.0 */
import { JisonLexer, JisonLexerApi } from '@ts-jison/lexer';

export class LexRegexpLexer extends JisonLexer implements JisonLexerApi {
    options: any = {"moduleName":"LexRegexp"};
    constructor (yy = {}) {
        super(yy);
    }

    rules: RegExp[] = [
        /^(?:(\\[rfntv]))/,
        /^(?:\/\*(?:.|\n|\r)*?\*\/)/,
        /^(?:\/\/.*)/,
        /^(?:([^\\*+()${}|[\]\/.^?]+))/,
        /^(?:\|)/,
        /^(?:\[(?:\\\\|\\\]|[^\]])*\])/,
        /^(?:\(\?:)/,
        /^(?:\(\?=)/,
        /^(?:\(\?!)/,
        /^(?:\()/,
        /^(?:\))/,
        /^(?:\+)/,
        /^(?:\*)/,
        /^(?:\?)/,
        /^(?:\^)/,
        /^(?:,)/,
        /^(?:<<EOF>>)/,
        /^(?:<)/,
        /^(?:\/!)/,
        /^(?:\/)/,
        /^(?:(\\x[0-9A-F]{2}))/,
        /^(?:(\\u[0-9a-fA-F]{4}))/,
        /^(?:(\\c[A-Z]))/,
        /^(?:(\\[0-7]{1,3}))/,
        /^(?:(\\[sSbBwWdD]))/,
        /^(?:(\\[\\*+()${}|[\]\/.^?]))/,
        /^(?:\\.)/,
        /^(?:\$)/,
        /^(?:\.)/,
        /^(?:%options\b)/,
        /^(?:\{\d+(?:,\s?\d+|,)?\})/,
        /^(?:(\{[a-zA-Z_][a-zA-Z0-9_-]*\}))/,
        /^(?:\{)/,
        /^(?:\})/,
        /^(?:.)/,
        /^(?:$)/
    ];
    conditions: any = {"code":{"rules":[35],"inclusive":false},"start_condition":{"rules":[35],"inclusive":false},"options":{"rules":[35],"inclusive":false},"conditions":{"rules":[35],"inclusive":false},"action":{"rules":[35],"inclusive":false},"indented":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],"inclusive":true},"trail":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],"inclusive":true},"rules":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],"inclusive":true},"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],"inclusive":true}}
    performAction (yy:any,yy_:any,$avoiding_name_collisions:any,YY_START:any): any {
          var YYSTATE=YY_START;
        switch($avoiding_name_collisions) {
    case 0:yy_.yytext = decodeStringEscape(yy_.yytext.substring(1));                return 31;
    case 1:/* ignore */
      break;
    case 2:/* ignore */
      break;
    case 3:return 30;
    case 4:return 6;
    case 5:return 26;
    case 6:return 11;
    case 7:return 11;
    case 8:return 11;
    case 9:return 9;
    case 10:return 10;
    case 11:return 12;
    case 12:return 13;
    case 13:return 14;
    case 14:return 21;
    case 15:return ',';
    case 16:return 22;
    case 17:this.begin('conditions'); return '<';
    case 18:return 16;
    case 19:return 15;
    case 20:yy_.yytext = String.fromCharCode(parseInt(yy_.yytext.substring(2), 16)); return 31;
    case 21:yy_.yytext = String.fromCharCode(parseInt(yy_.yytext.substring(2), 16)); return 31;
    case 22:yy_.yytext = String.fromCodePoint(yy_.yytext.charCodeAt(2) - 64);        return 31;
    case 23:yy_.yytext = String.fromCharCode(parseInt(yy_.yytext.substring(1),  8)); return 31;
    case 24:return 27;
    case 25:return 28;
    case 26:yy_.yytext = yy_.yytext.replace(/^\\/g,''); return 31; // escaped special chars like '"'s
    case 27:return 22;
    case 28:return 20;
    case 29:yy.options = {}; this.begin('options');
      break;
    case 30:return 29;
    case 31:return 25;
    case 32:return '{';
    case 33:return '}';
    case 34:/* ignore bad characters */
      break;
    case 35:return 5;
        }
    }
}

;
function decodeStringEscape (c: string): string {
  switch (c) {
  case "\\": return "\\";
  case "r": return "\r";
  case "f": return "\f";
  case "n": return "\n";
  case "t": return "\t";
  case "v": return "\v";
  default: throw Error(`decodeStringEscape(${c}) - unknown character`);
  }
}
