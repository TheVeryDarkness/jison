# Generated Parser File Structure

Using the calculator example from the [README](../README.md#calculator-example):

### Generated calculator parser
The generated parser, e.g. `examples/ts-calculator.ts`, will start with the verbatim inclusions from between the `%{` `%}`:
``` typescript
function hexlify (str:string): string {
  return str.split('')
    .map(ch => '0x' + ch.charCodeAt(0).toString(16))
    .join(', ')
}
```
It imports the runtime functionality from [`@ts-jison/parser`](../parser):
``` typescript
import { JisonParser, JisonParserApi, StateType, SymbolsType, TerminalsType, ProductionsType, o } from '@ts-jison/parser';
```
The next constants factor out some redundancy from the the stored representation of the L{L,R} parser:
``` typescript
const $V0=[1,3], …;
```
The named parser class (see the `-n` argument for naming) extends `JisonParser` from [`@ts-jison/parser`](../parser) and stores state in an untyped `$?`:
``` typescript
export class TsCalcParser extends JisonParser implements JisonParserApi {
    $?: any;

    constructor (yy = {}, lexer = new TsCalcLexer(yy)) {
      super(yy, lexer);
    }
```
Symbols and tables provide an executable parser which is navigated by the `performAction` method:
``` typescript
    symbols_: SymbolsType = {"error":2,"expressions":3,"e":4,"EOF":5, …,"$accept":0,"$end":1};
    terminals_: TerminalsType = {2:"error",5:"EOF", …};
    productions_: ProductionsType = [0,[3,2], …];
    table: Array<StateType> = [{3:1,4:2,7:$V0}, …];
    defaultActions: {[key:number]: any} = {8:[2,1]};

    performAction (yytext:string, yyleng:number, yylineno:number, yy:any, yystate:number /* action[1] */, $$:any /* vstack */, _$:any /* lstack */): any {
/* this == yyval */
          var $0 = $$.length - 1;
        switch (yystate) {
case 1:
 if (yy.trace) yy.trace('returning', $$[$0-1]);
          return $$[$0-1]; 
break;
…
case 13:
this.$ = Math.PI;
break;
        }
    }
}
```
After the parser class is the lexer class. At present the lexer is not terribly efficient with large inputs as it uses regular expressions:
``` typescript
/* generated by ts-jison-lex 0.3.0 */
import { JisonLexer, JisonLexerApi } from '@ts-jison/lexer';
export class TsCalcLexer extends JisonLexer implements JisonLexerApi {
    options: any = {"moduleName":"TsCalc"};
    constructor (yy = {}) {
        super(yy);
    }

    rules: RegExp[] = [/^(?:\s+)/, …];
    conditions: any = {"INITIAL":{"rules":[0,1, …],"inclusive":true}}
    performAction (yy:any,yy_:any,$avoiding_name_collisions:any,YY_START:any): any {
          var YYSTATE=YY_START;
        switch($avoiding_name_collisions) {
    case 0:if (yy.trace) yy.trace(`skipping whitespace ${hexlify(yy_.yytext)}`)
      break;
    case 1:return 15
    …
    case 14:return 'INVALID'
        }
    }
}
```
