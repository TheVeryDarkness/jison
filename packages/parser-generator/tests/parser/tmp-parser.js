const { JisonParser, o } = require('@ts-jison/parser');
/**
 * parser generated by  @ts-jison/parser-generator 0.4.1-alpha.2
 * @returns Parser implementing JisonParserApi and a Lexer implementing JisonLexerApi.
 */
class parserParser extends JisonParser {
    constructor(yy = {}, lexer = new parserLexer(yy)) {
        super(yy, lexer);
        this.symbols_ = {"error":2,"expressions":3,"e":4,"EOF":5,"e_repetition_plus0":6,"e_option0":7,"phrase":8,"happy":9,"joy":10,"$accept":0,"$end":1};
        this.terminals_ = {2:"error",5:"EOF",9:"happy",10:"joy"};
        this.productions_ = [0,[3,2],[4,2],[8,4],[6,1],[6,2],[7,0],[7,1]];

        // shorten static method to just `o` for terse STATE_TABLE
        const $V0=[1,5],$V1=[5,9,10];
        const o = JisonParser.expandParseTable;
        this.table = [{3:1,4:2,6:3,8:4,9:$V0},{1:[3]},{5:[1,6]},{5:[2,6],7:7,8:8,9:$V0,10:[1,9]},o($V1,[2,4]),{9:[1,10]},{1:[2,1]},{5:[2,2]},o($V1,[2,5]),{5:[2,7]},{10:[1,11]},{10:[1,12]},o($V1,[2,3])];
        this.defaultActions = {6:[2,1],7:[2,2],9:[2,7]};
    }
    performAction (yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */
          const $0 = $$.length - 1;
        switch (yystate) {
case 1:
return $$[$0-1];
break;
case 2:
this.$ = $$[$0-1] + ' ' + yytext ;
break;
case 3:
this.$ = [$$[$0-3], $$[$0-2], $$[$0-1], $$[$0]].join(' '); ;
break;
case 4:
this.$ = [$$[$0]];
break;
case 5:
$$[$0-1].push($$[$0]);
break;
        }
    }
}

// Export module
Object.defineProperty(exports, "__esModule", { value: true });
exports.parserParser = parserParser;

